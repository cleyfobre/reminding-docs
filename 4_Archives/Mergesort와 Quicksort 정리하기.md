#algorithm #cs

**Merge Sort (병합 정렬)** 과 **Quick Sort (퀵 정렬)** 은 배열이나 리스트를 정렬하는 데 사용되는 두 가지 효율적인 정렬 알고리즘입니다. 이들은 분할 정복(divide and conquer) 전략을 사용하여 작동합니다.

#### Merge Sort (병합 정렬)

병합 정렬은 데이터를 반으로 나누고, 각 부분을 재귀적으로 정렬한 다음, 두 개의 정렬된 목록을 하나의 정렬된 목록으로 병합하는 방식으로 작동합니다. 병합 정렬의 주요 단계는 다음과 같습니다:

1. **분할(Divide)**: 배열을 두 개의 동등한(또는 거의 동등한) 부분으로 나눕니다.
2. **정복(Conquer)**: 각 부분을 재귀적으로 정렬합니다. 이것은 단일 요소가 남을 때까지 계속됩니다.
3. **병합(Combine)**: 두 개의 정렬된 부분 배열을 하나의 정렬된 배열로 병합합니다.

병합 정렬은 안정적인 정렬 방법이며, 평균적으로도 최악의 경우에도 O(N log N)의 시간 복잡도를 가집니다. 그러나 추가적인 메모리가 필요한 단점이 있습니다.

#### Quick Sort (퀵 정렬)

퀵 정렬은 피벗(pivot)이라고 불리는 배열의 요소를 선택하고, 피벗보다 작은 모든 요소를 피벗의 왼쪽에, 피벗보다 큰 모든 요소를 피벗의 오른쪽에 배치합니다. 피벗의 위치는 이제 정렬된 위치가 됩니다. 이후, 피벗을 제외한 왼쪽과 오른쪽 부분 배열에 대해 동일한 과정을 재귀적으로 반복합니다. 퀵 정렬의 주요 단계는 다음과 같습니다:

1. **피벗 선택(Choose Pivot)**: 배열에서 피벗 요소를 선택합니다.
2. **분할(Partition)**: 피벗보다 작은 요소는 피벗의 왼쪽에, 큰 요소는 오른쪽에 위치하도록 배열을 분할합니다.
3. **재귀적 정렬(Recursive Sort)**: 피벗의 왼쪽과 오른쪽에 있는 부분 배열에 대해 재귀적으로 퀵 정렬을 적용합니다.

퀵 정렬은 평균적으로 O(N log N)의 시간 복잡도를 가지지만, 최악의 경우(이미 정렬되어 있거나 역순으로 정렬된 배열에서 피벗 선택이 최악일 때) O(N^2)까지 떨어질 수 있습니다. 그러나 일반적인 경우에 퀵 정렬은 병합 정렬보다 빠르고, 추가적인 메모리를 거의 또는 전혀 필요로 하지 않는다는 이점이 있습니다.