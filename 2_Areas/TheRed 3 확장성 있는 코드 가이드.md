#fastcampus #mau #msa #architecture #data #thered #디자인패턴 #architecture 

코드 레벨에서 확장성이 있으려면 다음 사항들이 고려되어야 한다.
1. 언어 선정
2. 테이블 설계
3. 디자인 패턴
4. 버전 관리

#### 프로그래밍 패러다임의 변천사
1. 초기에는 절차적 프로그래밍이 있었다. 명시된 입력을 받아서 명시된 순서로 처리하는 것을 말한다. 하지만 너무 복잡한 문제를 일으켰다.
2. 그래서 구조적 프로그래밍이 나오게 되었다. 코드를 함수로 쪼개는 방식(Top Down)이다. 하지만 데이터 구조화가 어렵다는 단점이 생겼다.
3. 다음은 객체지향 프로그래밍이 나오게 된다. 데이터와 관련 코드를 결합한 작은 객체를 기본 단위로 큰 문제를 해결하는 방식이다. (Bottom Up) 하지만 소프트웨어가 거대해지면서 이 역시 복잡해지기 시작했다.
4. 그래서 디자인 패턴이 출현하게 되었다. 디자인 패턴은 복잡한 문제를 해결한 Best Practice (모범 사례)를 말한다.
5. 디자인 패턴의 사례 중에 객체합성 구조(Object Composition)가 있다. 사용자는 인터페이스만 보고 사용 가능하다.

```java
MyService service = new RedisServiceImpl();
MyService service = new MongoServiceImpl();
service.doSomething();
```

#### 함수형 언어모델
1. 이해하기 쉽다.
2. 디버깅이 쉽다.
3. 내결함성(Fault Tolerance)이 높다.
4. 쓰레드 안정성(Thread Safety)으로 동시성 병렬 프로그래밍이 쉽다.

> 함수형 프로그래밍은 객체 지향 프로그래밍과 다르다. 따라서 객체 지향 디자인 패턴은 적용되지 않는다. 대신 함수형 프로그래밍 디자인 패턴은 있다.
> By GoF

그렇다면 함수형 프로그래밍의 디자인 패턴은 무엇이 있을까?

1. 커링 패턴(Function Composition)
고차함수: 함수를 인자로 받거나 결과로 반환하는 함수. 함수의 재사용성 확보.

> [!note] 디자인 패턴을 공부하자
> 코드 레벨 확장성은 습득이 어렵다. 특정 언어 패러다임에 한번 익숙해지면 습관을 버리기 어렵다. 디자인 패턴 공부하자.

#### 논리적 데이터 아키텍처

보통 데이터 스키마 혹은 논리적 데이터 모델이라고 한다. 논리적 모델은 흔히 객체 기반의 개체-관계 ER 모델(Entity Relationship)과 행 기반의 관계형 모델(Relational)을 사용한다. NoSql 데이터 모델은 모두 Nested Key Value Pairs 다차원 모델을 사용한다.

다음은 ER 모델의 기본과 예시이다.

![[Pasted image 20231229122444.png]]
![[Pasted image 20231229122516.png | 684]]

#### ORM

관계형 데이터 모델을 OOP의 엔터티로 투영(Mapping)하는 방법이다. ORM을 쓰는 이유는 _지속적인 서비스 소프트웨어의 개발과 배포_ 이다. 보통 ORM을 DB와 소프트웨어 중간의 Persistence Layer(영속성 계층)라고 한다. 그리고 다음과 같은 장점이 있다고 하는데.. 난 이해가 잘 안되는 부분도 있어서 내 생각과 같이 적어봤다.

**ORM의 장점들과 내 생각**
1. DBMS에 대한 종속성이 줄어든다. DBMS 교체 작업 때 해야할 일이 줄어든다.
	1. _교체 작업이라해봐야 Configuration 수정 작업밖에 더 있을까? 그 작업은 어차피 하는건데.. 만약 스키마가 바뀌면 엔터티도 바뀌는 것은 마찬가지 아닐까._
2. 재사용 및 유지보수가 가능하다. 데이터에 대한 객체를 별도로 관리하기 때문에 재활용할 수 있다.
3. 직관적인 코드다. 선언문, 할당, 종료 등 부수적인 코드가 사라진다. 객체 지향코드다.
	1. _스키마가 복잡해지면 오히려 쿼리가 직관적이고 보기 좋더라. 그리고 부수적인 코드는 Configuration 파일 안에 선언을 해놓는 경우가 많기 때문에 비즈니스 로직 구현하는 데 쓸데없이 코드가 길어지거나 하질 않는다._
4. 대규모 서비스의 업데이트는 부분적으로 진행되는 경우가 많은데, 데이터의 이전 버전과 새 버전을 동시에 관리할 수 있도록 ORM 레이어링을 통한 적절한 유연성이 갖출 수 있다.

#### 무중단 배포

- 롤링 배포: 순차적으로 패치하는 방식이다. Backward compatibility 관리가 필요하다. ! ![[Pasted image 20231229142216.png]]

- Blue Green 배포: 전체 서버를 스와핑하는 방식이다. 비용이 많이 든다. ![[Pasted image 20231229142108.png]]

- 카나리 배포: 트래픽을 순차적으로 이주시키는 방식이다. Backward compatibility 관리가 필요하다. ![[Pasted image 20231229142450.png]]

